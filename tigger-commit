#!/bin/dash


. tigger-utilities
check_repo_exists



  #################
 #    Defines    #
#################

COMMIT_DIR="$REPO/commit/$("find_where_head_points")" #is the active commit dir
OPTION_A=$FALSE
OPTION_M=$FALSE



  #################
 #   Functions   #
#################


#retreives the latest commit number
find_commit_number()
{
	next_commit=$(ls "$REPO/commit"|wc -l |xargs)
	echo -n "$next_commit"
}


is_index_empty()
{
	index_contents=$(ls -A1 "$REPO/index"|wc -l|xargs)
	if [ "$index_contents" -eq 0 ] 
	then
		return $TRUE
	else
		return $FALSE
	fi
}


is_file_in_repo()
{
  commit_file="$1"

  if [ -f "$commit_file" ] 
  then
    return $TRUE
  else
    return $FALSE
  fi
}

is_file_in_index()
{
  index_file="$1"
  file_name=$(basename "$index_file")
  index_file="$REPO/index/$file_name"
  if [ -f "$index_file" ] 
  then
    return $TRUE
  else
    return $FALSE
  fi
}

is_file_in_repo_diff_to_index()
{
	commit_file="$1"
	index_file="$2"
	is_difference=$(diff -q "$commit_file" "$index_file"|wc -c| tr -d ' ') 2> /dev/null
	if [ "$is_difference" -ne  0 ]
	then
		return $TRUE
	else
		return $FALSE
	fi
}

# Only commit if new files appear or file changes found.
is_there_any_changes_to_commit()
{
	#loop through both directories while ignoring duplicates
	for file in $(basename --multiple "$COMMIT_DIR"/*  "$INDEX_DIR"/* |sort|uniq|xargs)
	do 
		is_file_in_repo "$COMMIT_DIR/$file"  || return $TRUE
		is_file_in_index "$INDEX_DIR/$file"  || return $TRUE
		! is_file_in_repo_diff_to_index "$COMMIT_DIR/$file" "$INDEX_DIR/$file" || return $TRUE
	done

	return $FALSE
}


#TODO: make this function log seperatley for different branches
#logs commits messages into '.log'
log_comment()
{
	
	commit="$1"
	comment="$2"

	if [ ! -s "$REPO/.log" ]
	then
		echo "$1 $2" > "$REPO/.log"
	else 
		tmp=$(cat -- "$REPO/.log")
		echo  "$1 $2" > "$REPO/.log"
		echo "$tmp" >> "$REPO/.log"
	fi

}


# Merging two branches will require a common ancestor branch to compare with.
# This function will create a hidden file in each commit which will keep track 
# of each commits lineage so that it will be easy to find the last common 
# ancestor between any two commits.
# for example           the lineage of commit 5 may be: 5->4->1->0->NULL
# and the lineage of commit 3 on another branch may be: 3->2->1->0->NULL
# The last common ancestor of both commits can easily be found as commit 1.
# Hence, when merging the branches pointing to commit 5 and 3, commit 1 will be used
# as the base of comparison. 
create_lineage()
{
	parent_commit=$1
	next_commit=$2

	if [ "$parent_commit" = "NULL" ]
	then
		echo -n '0->NULL' > "$REPO/commit/$next_commit/.lineage" || 
		die "$PRGRM: error: unable to create .lineage"
		
	else
		curr_lineage=$(sed "s/^/$next_commit->/" "$REPO/commit/$parent_commit/.lineage")
		echo -n "$curr_lineage" > "$REPO/commit/$next_commit/.lineage" || 
		die "$PRGRM: error: unable to append .lineage"
	fi
}




  #################
 #     Main      #
#################


curr_branch="$(find_head)"
parent_commit=$(basename "$COMMIT_DIR")
next_commit=$(find_commit_number)


# -m option needs a message
# -a updates files in index 
while getopts ':am' opt
do
  case "$opt" in 
		a) OPTION_A=$TRUE;;
		m) OPTION_M=$TRUE;;	
		\?)die "usage: $PRGRM [-a] -m commit-message";;

  esac
done


#if option -m present then check for message
if [ "$OPTION_M" -eq "$TRUE" ] 
then
	shift "$(($OPTIND - 1))"
	message="$@"
fi


#if no message given
[ -n "$message" ] || die "usage: $PRGRM [-a] -m commit-message"


[ "$OPTION_A" -eq "$TRUE" ] && die "TO DO LATER"

#to check for changes to the commit a commit dir must first exist. The 'if NULL' prevents
#errors due to checking a commit directory that doesnt exist
#set -x
if [ "$parent_commit" = "NULL" ] 
then
	is_index_empty  && die "nothing to commit"
else
	is_there_any_changes_to_commit || die "nothing to commit"
fi
#set +x


#create new commit
mkdir "$REPO/commit/$next_commit" || die "$PRGRM: error: unable to create commit directory $next_commit"

#update the branch so that it now points to this latest commit
echo "$next_commit" > "$REPO/heads/$curr_branch" 


create_lineage "$parent_commit" "$next_commit"


#Copy contents of index to next_commit
rsync -a "$REPO/index/" "$REPO/commit/$next_commit" 
echo "Committed as commit $next_commit"

log_comment "$next_commit" "$@"














